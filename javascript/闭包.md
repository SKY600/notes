### 定义：
闭包 就是 能提供给外部环境 访问 函数内部变量的函数。「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。

### 作用：
正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的 变量,在函数执行完之后依旧保持没有被垃圾回收处理掉。

由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“，所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。

### 三个特性：
1. 函数嵌套函数
2. 函数内部可以引用外部的参数和变量
3. 参数和变量不会被垃圾回收机制回收

### 优点：
1. 逻辑连续，当闭包作为另一个函数调用的参数时，避免你脱离当前逻辑而单独编写额外逻辑。
2. 方便调用上下文的局部变量。
3. 加强封装性，第2点的延伸，可以达到对变量的保护作用。

### 缺点：
闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当会造成无效内存的产生。

### 实例：
```
// 创建闭包最常见的方式函数作为返回值
function foo() {
  var name = "kebi";
  return function() {
    console.log(name);
  };
}
var bar = foo();
bar(); //打印kebi    --外部函数访问内部变量
```

接下来实现一个计数器大家肯定会觉得这不是很简单吗

```
var count = 0;
function add() {
  count = count + 1;
  console.log(count);
}
add(); //确实实现了需求

//但是如果需要第二个计数器呢?
//难道要如下这样写吗?
var count1 = 0;
function add1() {
  count1 = count1 + 1;
  console.log(count1);
}
add1(); //确实实现了需求
```

当我们需要更多地时候,这样明显是不现实的,这里我们就需要用到闭包。

```
function addCount() {
  var conut = 0;
  return function() {
    count = count + 1;
    console.log(count);
  };
}
```

这里解释一下上边的过程: addCount() 执行的时候, 返回一个函数, 函数是可以创建自己的作用域的, 但是此时返回的这个函数内部需要引用 addCount() 作用域下的变量 count, 因此这个 count 是不能被销毁的.接下来需要几个计数器我们就定义几个变量就可以,并且他们都不会互相影响,每个函数作用域中还会保存 count 变量不被销毁,进行不断的累加。

```
var fun1 = addCount();
fun1(); //1
fun1(); //2
var fun2 = addCount();
fun2(); //1
fun2(); //2
```

常见面试题

```
for (var i = 1; i <= 5; i++) {
  setTimeout( function timer() {
      console.log(i);
  }, 1000 );
}
```

上面的代码会输出什么？怎么改动上述代码，使其依次输出1、2、3、4、5

答案是  程序会同时输出6 6 6 6 6，

setTimeout()相关知识

在我们学习setTimeout的时候就知道，setTimeout有两个参数，第一个参数是回调函数，第二个参数是毫秒数，表示要执行回调函数所要延迟的时间。但我们还需要知道的是，setTimeout会返回一个Id，即这个定时器的Id，在上面的代码中其实已经创建了5个定时器。

接下来就该讨论为什么会输出5个数字6，而不是1、2、3、4、5了。

因为setTimeout()函数要等执行完函数调用栈中的代码，然后立即调用定时器。这是因为，我们的定时器都被放在了一个被称为队列的数据结构中，等待上下文的可执行代码运行完毕后，才开始运行定时器，也就是定时器才刚开始同时计时。所以在定时器的方法执行的时候，变量i已经变成了6，所以输出的全部是6。

那么怎么样才能输出1、2、3、4、5呢？

因为5个定时器所打印出来的是同一个i变量，所以想要实现输出不同的数字，就需要把每个定时器所访问的变量独立起来，这就用到了JavaScript的闭包。闭包用途很多，可以很好地区分开各个作用域，避免变量的混淆，但是滥用闭包也会导致性能问题。那么通过下面的修改就可以了；

```
for (var i = 1; i <= 5; i++) {
    (function(i){
        setTimeout( function timer() {
              console.log(i);
          },  1000 );
    })(i);
}
```

块级作用域--关键字let

使用闭包可以得到正确的结果，原因就是改变了i的作用域，那如果我们把循环中的每个setTimeout都独立成一个作用域是不是也能实现同样的结果呢？我们都知道，在JavaScript中，每个函数是一个独立的作用域，但是“{}”是不能形成独立作用域的。

在ES6中提出了一个新的关键字let，就可以声明一个仅对当前“{}”内部有作用的变量。输出的结果是一样。

```
for (let i = 1; i <= 5; i++) {
  setTimeout( function timer() {
      console.log(i);
  }, 1000 );
}
```