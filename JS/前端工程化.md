### 对前端架构师的理解
* 负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率； 
* 带领团队完成研发工具及平台前端部分的设计、研发和维护； 
* 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先 
* 负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。

### 背景
目前来说，web业务日益复杂化和多元化，前端开发从WebPage模式为主转变为WebApp模式为主了。前端的开发工作在一些场景下被认为只是日常的一项简单工作，或只是某个项目的"附属品"，并没有被当做一个"软件"而认真对待（无论是产品负责人还是开发者）。

在模式的转变下，前端都已经不是过去的拼几个页面和搞几个jq插件就能完成。

当工程复杂就会产生许多问题，比如：
* 如何进行高效的多人协作？
* 如何保证项目的可维护性？
* 如何提高项目的开发质量？
* 如何降低项目生产的风险？
* ...

### 定义
<b>前端工程化</b>是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的<b>*为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间*</b>，而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。

"前端工程化"里面的工程指<b>软件工程</b>，和我们一般说的工程是两个完全不同的概念。

* <b>工程</b>是个很泛泛的概念，甚至可以认为建了一个git仓库就相对于新建了一个工程；
* <b>软件工程</b>的定义是: "应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科"（GB/T11457-2006《信息技术 软件工程术语》）。

### 如何做"前端工程化"？
前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从<b>模块化、组件化、规范化、自动化</b>四个方面思考。
#### 模块化
简单来说，模块化就是将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。
* <b>JS的模块化</b>

在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD等。

现在ES6已经在语言层面上规定了模块系统，完全可以取代现有的CommonJS和AMD规范，而且使用起来相当简洁，并且有静态加载的特性。
1. 用++Webpack + Babel++将所有模块打包成一个文件同步加载，也可以搭乘多个chunk异步加载；
2. 用++System+Babel++主要是分模块异步加载；
3. 用浏览器的```<script type="module">```加载。

* <b>css的模块化</b>

虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。

按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。虽然重写样式是CSS的一个优势，但这并不利于多人协作。

为了避免全局选择器的冲突，需要制定CSS命名风格：
1. BEM风格
2. Bootstrap风格
3. ...

但是这毕竟是弱约束。所以很赞同一句话：<br>
与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。

从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。
1. Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；
2. CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；
3. CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。

* <b>资源的模块化</b>
Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。

资源模块化后，优点是：
1. 依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；
2. 资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等；
3. 项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数： dest = webpack(src, config)。

#### 组件化
从UI拆分下来的<b>每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元</b>，我们称之为<b>组件</b>。<br>
<b>组件化≠模块化</b>。模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。

其实，组件化更重要是一种分治思想。

Keep Simple. Everything can be a component.

页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。

传统前端框架/类库的思想是先组织DOM，然后把某些可复用的逻辑封装成组件来操作DOM，是DOM优先；而组件化框架/类库的思想是先来构思组件，然后用DOM这种基本单元结合相应逻辑来实现组件，是组件优先。这是两者本质的区别。

其次，组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)三位一体的形式<b>对面向对象的进一步抽象。</b>

所以我们除了封装组件本身，还要合理处理组件之间的关系，比如 <b>（逻辑）继承、（样式）扩展、（模板）嵌套</b>和<b>包含</b>等，这些关系都可以归为依赖。

目前市面上的组件化框架很多，主要的有Vue、React、Angular。Vue文档中的对比其他框架一文已经讲得很详细了。

#### 规范化
规范化其实是工程化中很重要的一个部分，项目初期规范制定的好坏会直接影响到后期的开发质量。

比如：
* 目录结构的制定：目录结构的合理设定，能为项目带来很多优点：
* 有助于提高项目的逻辑结构合理性；
* 对应扩展和合作；
* 方便资源的统一定位管理。
* 编码规范：
    * HTML规范<br>
    基于 W3C、苹果开发者 等官方文档，并结合团队业务和开发过程中总结的规范约定，让页面HTML代码更具语义性。
	* CSS规范<br>
    统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
	* JS规范<br>
    统一规范团队 CSS 代码书写风格和使用 CSS 预编译语言语法风格，提供常用媒体查询语句和浏览器私有属性引用，并从业务层面统一规范常用模块的引用。
	* 图片规范<br>
    了解各种图片格式特性，根据特性制定图片规范，包括但不限于图片的质量约定、图片引入方式、图片合并处理等，旨在从图片层面优化页面性能。
	* 命名规范<br>
    从 目录、图片、HTML/CSS文件、ClassName 的命名等层面约定规范团队的命名习惯，增强团队代码的可读性。

* 前后端接口规范
    1. <b>职责分离</b>
    * 前后端仅仅通过异步接口(AJAX/JSONP)来编程；
	* 前后端都各自有自己的开发流程，构建工具，测试集合；
	* 关注点分离，前后端变得相对独立并松耦合。
    | 后端 | 前端 |
    | - | - |
    | 提供数据 | 接收数据，返回数据 |
    | 处理业务逻辑 | 处理渲染逻辑 |	

    2. <b>规范原则</b>
    * 接口返回数据即显示，前端仅做渲染逻辑处理；
	* 渲染逻辑禁止跨多个接口调用；
	* 前端关注交互、渲染逻辑，尽量避免业务逻辑处理的出现；
	* 请求响应传输数据格式：JSON，JSON数据尽量简单轻量，避免多级JSON的出现；

	3. <b>响应格式</b>
    * 响应基本格式及处理状态值的规范。
        * 基本响应格式
		* 列表响应格式
	* 特殊内容
        * 下拉框、复选框、单选框统一由后端逻辑判定选中返回给前端展示；
		* 关于Boolean类型，JSON数据传输中一律使用1/0来标示，1为是/True，0为否/False
		* 关于日期类型，JSON数据传输中一律使用字符串，具体日期格式因业务而定；
* 文档规范
* 组件管理
* git分支管理
* commit描述规范
* 视觉图标规范
* ...

#### 自动化
前端工程化的很多脏活累活都应该交给自动化工具来完成。需要秉持的一个理念是:
> 任何简单机械的重复劳动都应该让机器去完成。
* 图标合并
* 持续继承
* 自动化构建
* 自动化部署
* 自动化测试


